// SPDX-License-Identifier: MIT
namespace didtoolbox {
};

/// The error accompanying TrustDidWebId.
/// It might occur while calling TrustDidWebId methods.
[Error]
enum TrustDidWebIdResolutionError {
    /// DID method is not supported by this resolver.
    "MethodNotSupported",
    /// Invalid method-specific identifier.
    "InvalidMethodSpecificId"
};

/// Represents a TDW DID, as specified at https://identity.foundation/trustdidweb/#method-specific-identifier:
///
/// "The did:tdw method-specific identifier contains both the self-certifying identifier (SCID) for the DID,
/// and a fully qualified domain name (with an optional path) that is secured by a TLS/SSL certificate."
interface TrustDidWebId {
    /// The only (non-empty) constructor in charge of DID parsing.
    ///
    /// CAUTION Calling any of the available getters should take place after this method is called, not earlier.
    [Name=parse_did_tdw, Throws=TrustDidWebIdResolutionError]
    constructor(string did_tdw, boolean? allow_http);
    /// Returns the SCID part from the supplied DID.
    string get_scid();
    /// Returns the url part from the supplied TDW DID.
    string get_url();
};

/// The error accompanying TrustDidWeb.
/// It might occur while calling TrustDidWeb methods.
[Error]
enum TrustDidWebError {
    /// DID method is not supported by this resolver.
    "MethodNotSupported",
    /// Invalid method-specific identifier.
    "InvalidMethodSpecificId",
    /// TODO Complete this docstring
    "SerializationFailed",
    /// The supplied did doc is invalid or contains an argument which isn't part of the did specification/recommendation.
    "DeserializationFailed",
    /// Invalid (or not yet supported) operation against DID doc.
    "InvalidOperation"
};

interface TrustDidWeb {
    [Name=read, Throws=TrustDidWebError]
    constructor(string did_tdw, string did_log, boolean? allow_http);
    string get_did();
    string get_did_log();
    string get_did_doc();
};

interface Ed25519Signature {
    [Name=from_multibase]
    constructor([ByRef] string multibase);
    string to_multibase();
};

interface Ed25519SigningKey {
    [Name=from_multibase]
    constructor([ByRef] string multibase);
    string to_multibase();
};

interface Ed25519VerifyingKey {
    [Name=from_multibase]
    constructor([ByRef] string multibase);
    string to_multibase();
};

interface Ed25519KeyPair {
    [Name=generate]
    constructor();
    [Name=from]
    constructor([ByRef] string signing_key_multibase);
    Ed25519Signature sign(string message);
    Ed25519SigningKey get_signing_key();
    Ed25519VerifyingKey get_verifying_key();
};

interface DidDocumentState {
    [Name=from]
    constructor(string did_log);
    DidDoc validate();
    DidDoc validate_with_scid(string? scid);
};

dictionary Jwk {
  string? alg;
  string? kid;
  string? kty;
  string? crv;
  string? x;
  string? y;
};

enum VerificationType {
    "Multikey",
    "JsonWebKey2020",
    "Ed25519VerificationKey2020",
};

dictionary VerificationMethod {
    string id;
    string controller;
    VerificationType verification_type;
    string? public_key_multibase;
    Jwk? public_key_jwk;
};

interface DidDoc {
    [Name=from_json]
    constructor([ByRef] string json_content);
    sequence<string> get_context();
    string get_id();
    sequence<VerificationMethod> get_verification_method();
    sequence<VerificationMethod> get_authentication();
    sequence<VerificationMethod> get_capability_invocation();
    sequence<VerificationMethod> get_capability_delegation();
    sequence<VerificationMethod> get_assertion_method();
    sequence<string> get_controller();
    boolean get_deactivated();
};